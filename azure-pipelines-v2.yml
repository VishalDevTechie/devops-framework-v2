trigger:
  branches:
    include: ['main', 'develop', 'release/*']
  paths:
    exclude: ['README.md', 'docs/*']

pr:
  branches:
    include: ['main', 'develop']

resources:
  repositories:
    - repository: framework
      type: github
      name: VishalDevTechie/devops-framework-v2
      ref: development
      endpoint: GitHub connection
    - repository: service
      type: github
      name: VishalDevTechie/dsa-visualizer
      ref: development
      endpoint: GitHub connection

pool:
  name: Default

parameters:
  - name: deploymentMode
    displayName: "Deployment Mode"
    type: string
    default: smart-auto
    values:
      - smart-auto        # Full auto-detection and deployment
      - analysis-only     # Analysis and config generation only
      - build-only       # Build and containerize only
      - full-pipeline    # Complete pipeline with deployment

variables:
  DOCKER_SERVICE_CONNECTION: 'DockerHubConnection'
  AKS_SERVICE_CONNECTION: 'AKSConnection'
  DOCKER_REPOSITORY: 'vishal10101'
  DEPLOYMENT_MODE: ${{ parameters.deploymentMode }}

stages:
  - stage: SmartAnalysis
    displayName: 'Smart Framework Analysis'
    jobs:
      - job: AnalyzeApplication
        displayName: 'Analyze Angular Application'
        steps:
          - checkout: framework
            displayName: 'Checkout DevOps Framework'
            path: s/framework
          
          - checkout: service
            displayName: 'Checkout Service Application'
            path: s/service
          
          - task: UsePythonVersion@0
            displayName: 'Setup Python'
            inputs:
              versionSpec: '3.9'
              addToPath: true
          
          - task: PowerShell@2
            displayName: 'Install Framework Dependencies'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Installing Framework Dependencies" -ForegroundColor Green
                Write-Host "Agent working directory: $(Agent.BuildDirectory)"
                Write-Host "Build source directory: $(Build.SourcesDirectory)"
                
                # Navigate to framework directory using the correct path
                $frameworkPath = Join-Path "$(Build.SourcesDirectory)" "framework"
                Write-Host "Framework path: $frameworkPath"
                
                # Check if framework directory exists
                if (Test-Path $frameworkPath) {
                    Write-Host "Framework directory found" -ForegroundColor Green
                    Set-Location $frameworkPath
                    Write-Host "Changed to framework directory"
                    Write-Host "Current directory: $(Get-Location)"
                    
                    # List contents to verify
                    Write-Host "Directory contents:"
                    Get-ChildItem | Format-Table Name, Length, LastWriteTime
                    
                    if (Test-Path "requirements.txt") {
                        Write-Host "Installing Python dependencies..." -ForegroundColor Yellow
                        python -m pip install --upgrade pip
                        pip install -r requirements.txt
                        
                        if ($LASTEXITCODE -eq 0) {
                            Write-Host "Dependencies installed successfully" -ForegroundColor Green
                        } else {
                            Write-Host "Failed to install dependencies" -ForegroundColor Red
                            exit 1
                        }
                    } else {
                        Write-Host "requirements.txt not found in framework directory" -ForegroundColor Red
                        Write-Host "Available files:"
                        Get-ChildItem | Format-Table Name
                        exit 1
                    }
                } else {
                    Write-Host "Framework directory not found at: $frameworkPath" -ForegroundColor Red
                    Write-Host "Available directories in Build.SourcesDirectory:"
                    Get-ChildItem "$(Build.SourcesDirectory)" | Where-Object {$_.PSIsContainer} | Format-Table Name
                    exit 1
                }
          
          - task: PowerShell@2
            displayName: 'Run Smart Analysis'
            inputs:
              targetType: 'inline'
              workingDirectory: '$(Build.SourcesDirectory)/framework'
              script: |
                Write-Host "Starting Smart Analysis" -ForegroundColor Cyan
                Write-Host "Working directory: $(Get-Location)"
                
                # Verify directories
                $servicePath = Join-Path "$(Build.SourcesDirectory)" "service"
                Write-Host "Service path: $servicePath"
                
                if (-not (Test-Path $servicePath)) {
                    Write-Host "ERROR: Service repository not found" -ForegroundColor Red
                    exit 1
                }
                
                # Create and execute Python script
                $analysisScript = @"
import sys
import os
import json
from pathlib import Path

print('='*60)
print('Starting Smart Framework Analysis')
print('='*60)

# Setup paths
current_dir = os.getcwd()
scripts_dir = os.path.join(current_dir, 'scripts')
service_path = r'$servicePath'

print(f'\nCurrent directory: {current_dir}')
print(f'Scripts directory: {scripts_dir}')
print(f'Service repository: {service_path}')

# Add scripts to Python path
if os.path.exists(scripts_dir):
    sys.path.insert(0, scripts_dir)
    print(f'âœ… Added scripts to Python path')
else:
    print(f'âŒ Scripts directory not found')
    sys.exit(1)

# Verify service repository
if not os.path.exists(service_path):
    print(f'âŒ Service repository not found at: {service_path}')
    sys.exit(1)

try:
    # Import orchestrator
    print('\nðŸ“¦ Importing SmartOrchestrator...')
    from smart_orchestrator import SmartOrchestrator
    print('âœ… SmartOrchestrator imported successfully')
    
    # Initialize and run analysis
    print('\nðŸ” Initializing orchestrator...')
    orchestrator = SmartOrchestrator()
    
    print(f'\nðŸ”Ž Analyzing repository: {service_path}')
    result = orchestrator.analyze_only(service_path)
    
    # Save results
    output_file = 'analysis-results.json'
    with open(output_file, 'w') as f:
        json.dump(result, f, indent=2, default=str)
    print(f'\nðŸ’¾ Results saved to: {output_file}')
    
    # Display results
    print('\n' + '='*60)
    if result['success']:
        print('âœ… ANALYSIS COMPLETED SUCCESSFULLY')
        print('='*60)
        
        config = result.get('config', {})
        app = config.get('app', {})
        detection = config.get('detection', {})
        build_strategy = config.get('build_strategy', {})
        docker = config.get('docker', {})
        
        print(f'\nðŸ“‹ Application Details:')
        print(f'  Name: {app.get("name", "unknown")}')
        print(f'  Framework: {app.get("framework", "unknown")}')
        print(f'  Confidence: {detection.get("confidence", 0):.1%}')
        
        print(f'\nðŸ”¨ Build Strategy:')
        print(f'  Command: {build_strategy.get("command", "unknown")}')
        print(f'  Type: {build_strategy.get("type", "unknown")}')
        
        print(f'\nðŸ³ Docker Configuration:')
        print(f'  Image: {docker.get("full_image", "unknown")}')
        print(f'  Port: {docker.get("port", "unknown")}')
        
        print('\n' + '='*60)
        sys.exit(0)
    else:
        print('âŒ ANALYSIS FAILED')
        print('='*60)
        print(f'\nError: {result.get("error", "Unknown error")}')
        sys.exit(1)
        
except ImportError as e:
    print(f'\nâŒ Import Error: {e}')
    print('\nAvailable files in scripts directory:')
    if os.path.exists(scripts_dir):
        for item in os.listdir(scripts_dir):
            print(f'  - {item}')
    sys.exit(1)
    
except Exception as e:
    print(f'\nâŒ Unexpected Error: {e}')
    import traceback
    print('\nFull traceback:')
    traceback.print_exc()
    sys.exit(1)
"@
                
                # Save script to file
                $analysisScript | Out-File -FilePath "run_analysis.py" -Encoding UTF8 -NoNewline
                
                # Execute Python script
                Write-Host "`nExecuting Python analysis..." -ForegroundColor Yellow
                python run_analysis.py
                
                $exitCode = $LASTEXITCODE
                if ($exitCode -ne 0) {
                    Write-Host "`nâŒ Analysis failed with exit code: $exitCode" -ForegroundColor Red
                    exit $exitCode
                }
                
                Write-Host "`nâœ… Analysis step completed" -ForegroundColor Green
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Analysis Results'
            inputs:
              targetPath: '$(Build.SourcesDirectory)/framework/analysis-results.json'
              artifact: 'analysis-results'

  - stage: SmartBuild
    displayName: 'Smart Build & Containerize'
    dependsOn: SmartAnalysis
    condition: and(succeeded(), in(variables.DEPLOYMENT_MODE, 'smart-auto', 'build-only', 'full-pipeline'))
    jobs:
      - job: BuildApplication
        displayName: 'Build Angular Application'
        steps:
          - checkout: framework
            displayName: 'Checkout DevOps Framework'
            path: framework
          
          - checkout: service
            displayName: 'Checkout Service Application'
            path: service
          
          - task: DownloadPipelineArtifact@2
            inputs:
              artifact: 'analysis-results'
              path: $(Pipeline.Workspace)
          
          - task: UsePythonVersion@0
            inputs:
              versionSpec: '3.9'
          
          - task: PowerShell@2
            displayName: 'Install Framework Dependencies'
            inputs:
              targetType: 'inline'
              script: |
                $frameworkPath = Join-Path "$(Build.SourcesDirectory)" "framework"
                Set-Location $frameworkPath
                pip install -r requirements.txt
          
          - task: Docker@2
            displayName: 'Docker Login'
            inputs:
              command: 'login'
              containerRegistry: $(DOCKER_SERVICE_CONNECTION)
          
          - task: PythonScript@0
            displayName: 'Execute Smart Build Pipeline'
            inputs:
              scriptSource: 'inline'
              workingDirectory: '$(Build.SourcesDirectory)/framework'
              script: |
                import sys
                import json
                import os
                
                # Add scripts directory to Python path
                scripts_path = os.path.join(os.getcwd(), 'scripts')
                sys.path.insert(0, scripts_path)
                
                try:
                    from smart_orchestrator import SmartOrchestrator
                    
                    # Load analysis results
                    analysis_file = os.path.join('$(Pipeline.Workspace)', 'analysis-results.json')
                    with open(analysis_file) as f:
                        analysis_result = json.load(f)
                    
                    if not analysis_result['success']:
                        print("Cannot proceed - analysis failed")
                        sys.exit(1)
                    
                    # Initialize orchestrator
                    orchestrator = SmartOrchestrator()
                    
                    # Service repository path
                    service_path = os.path.join('$(Build.SourcesDirectory)', 'service')
                    
                    print(f"Framework working directory: {os.getcwd()}")
                    print(f"Service repository path: {service_path}")
                    print(f"Service repository exists: {os.path.exists(service_path)}")
                    
                    # Execute build and docker stages
                    config = analysis_result['config']
                    result = orchestrator.process_repository(service_path, config)
                    
                    if result['success']:
                        print("Build and containerization completed")
                    else:
                        print(f"Build failed: {result.get('error')}")
                        sys.exit(1)
                        
                except Exception as e:
                    print(f"Build pipeline error: {e}")
                    import traceback
                    traceback.print_exc()
                    sys.exit(1)
          
          - task: Docker@2
            displayName: 'Docker Logout'
            inputs:
              command: 'logout'
              containerRegistry: $(DOCKER_SERVICE_CONNECTION)
            condition: always()

  - stage: SmartDeploy
    displayName: 'Smart Deployment to AKS'
    dependsOn: SmartBuild
    condition: and(succeeded(), in(variables.DEPLOYMENT_MODE, 'smart-auto', 'full-pipeline'))
    jobs:
      - deployment: DeployToAKS
        displayName: 'Deploy to AKS Cluster'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: framework
                  displayName: 'Checkout DevOps Framework'
                  path: framework
                
                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Analysis Results'
                  inputs:
                    artifact: 'analysis-results'
                    path: $(Pipeline.Workspace)
                
                - task: UsePythonVersion@0
                  displayName: 'Setup Python'
                  inputs:
                    versionSpec: '3.9'
                
                - task: PowerShell@2
                  displayName: 'Install Framework Dependencies'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $frameworkPath = Join-Path "$(Build.SourcesDirectory)" "framework"
                      Set-Location $frameworkPath
                      pip install -r requirements.txt
                      Write-Host "Framework dependencies installed"
                
                - task: PythonScript@0
                  displayName: 'Generate Kubernetes Manifests'
                  inputs:
                    scriptSource: 'inline'
                    workingDirectory: '$(Build.SourcesDirectory)/framework'
                    script: |
                      import sys
                      import json
                      import os
                      
                      # Add scripts directory to Python path
                      scripts_path = os.path.join(os.getcwd(), 'scripts')
                      sys.path.insert(0, scripts_path)
                      
                      try:
                          from smart_deploy import run as deploy_run
                          
                          # Load configuration
                          analysis_file = os.path.join('$(Pipeline.Workspace)', 'analysis-results.json')
                          with open(analysis_file) as f:
                              analysis_result = json.load(f)
                          
                          if not analysis_result['success']:
                              print("Cannot deploy - analysis failed")
                              sys.exit(1)
                          
                          config = analysis_result['config']
                          
                          # Ensure deployment configuration exists
                          if 'deployment' not in config:
                              config['deployment'] = {
                                  'namespace': 'default',
                                  'environment': 'production',
                                  'replicas': 1
                              }
                          
                          print(f"Generating manifests for: {config['app']['name']}")
                          print(f"Docker Image: {config['docker']['full_image']}")
                          
                          # Generate manifests
                          deploy_result = deploy_run(config)
                          
                          if deploy_result['success']:
                              print("Kubernetes manifests generated successfully")
                              print(f"Manifest file: {deploy_result['manifest_path']}")
                              
                              # Display manifest preview
                              with open(deploy_result['manifest_path'], 'r') as f:
                                  manifest_content = f.read()
                                  print("\nGenerated Manifest Preview:")
                                  print("-" * 50)
                                  print(manifest_content[:1000] + "..." if len(manifest_content) > 1000 else manifest_content)
                                  print("-" * 50)
                          else:
                              print(f"Manifest generation failed: {deploy_result.get('error')}")
                              sys.exit(1)
                              
                      except Exception as e:
                          print(f"Deploy script error: {e}")
                          import traceback
                          traceback.print_exc()
                          sys.exit(1)
                
                - task: Kubernetes@1
                  displayName: 'Connect to AKS and Create Namespace'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(AKS_SERVICE_CONNECTION)
                    command: 'apply'
                    useConfigurationFile: true
                    configurationType: 'inline'
                    inline: |
                      apiVersion: v1
                      kind: Namespace
                      metadata:
                        name: default
                        labels:
                          managed-by: devops-framework-v2
                  continueOnError: true
                
                - task: Kubernetes@1
                  displayName: 'Deploy Application to AKS'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(AKS_SERVICE_CONNECTION)
                    command: 'apply'
                    useConfigurationFile: true
                    configurationType: 'filePath'
                    configuration: '$(Build.SourcesDirectory)/framework/generated-k8s-manifest.yaml'
                    outputFormat: 'yaml'
                
                - task: Kubernetes@1
                  displayName: 'Wait for Rollout to Complete'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(AKS_SERVICE_CONNECTION)
                    command: 'rollout'
                    arguments: 'status deployment/$(Build.Repository.Name) --timeout=300s --namespace=default'
                  timeoutInMinutes: 10
                
                - task: Kubernetes@1
                  displayName: 'Get Application Status'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(AKS_SERVICE_CONNECTION)
                    command: 'get'
                    arguments: 'all -l managed-by=devops-framework-v2 --namespace=default -o wide'
                
                - task: Kubernetes@1
                  displayName: 'Get Service External IP'
                  inputs:
                    connectionType: 'Kubernetes Service Connection'
                    kubernetesServiceEndpoint: $(AKS_SERVICE_CONNECTION)
                    command: 'get'
                    arguments: 'service --namespace=default -o wide'
                
                - task: PowerShell@2
                  displayName: 'Display Deployment Summary'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Deployment completed!" -ForegroundColor Green
                      Write-Host "Deployment Summary:" -ForegroundColor Cyan
                      Write-Host "  Application: $(Build.Repository.Name)" -ForegroundColor White
                      Write-Host "  Namespace: default" -ForegroundColor White
                      Write-Host "  Environment: production" -ForegroundColor White
                      Write-Host "  Build: $(Build.BuildNumber)" -ForegroundColor White
                      Write-Host ""
                      Write-Host "Next Steps:" -ForegroundColor Yellow
                      Write-Host "  1. Check the External IP from the service output above"
                      Write-Host "  2. Access your application at http://<EXTERNAL-IP>"
                      Write-Host "  3. Monitor deployment: kubectl get pods --namespace=default"